---
title: "MinneMUDAC DS - Novice Section"
subtitle: "Noah Lee"
output:
  pdf_document: default
  html_document: default
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup}
#| include: false
library(tidyverse)
library(tidymodels)
library(naniar)    
library(dplyr)
library(ggformula)
library(ggplot2) 
library(GGally)

library(lubridate)
library(ranger)   
library(workflows) 
library(recipes) 
tidymodels_prefer(quiet = TRUE) 
```

```{r}
df <- read.csv('../Data/Novice.csv')
```

```{r}
# Initial Inspection
print("Initial Inspection:")
str(df)
head(df)
```

Unnecessary Columns: 
```{r}
df$Match.ID.18Char <- NULL
df$Little.ID <- NULL
df$Big.ID <- NULL
df$Big.Occupation <- NULL
df$Big..Military <- NULL
df$Big.Employer <- NULL
df$Closure.Reason <- NULL
df$Closure.Details <- NULL
df$Big.Open.to.Cross.Gender.Match <- NULL
df$Big.Contact..Interest.Finder...Sports <- NULL
df$Big.Contact..Interest.Finder...Places.To.Go <- NULL
df$Big.Contact..Interest.Finder...Hobbies <- NULL
df$Big.Contact..Interest.Finder...Entertainment <- NULL
df$Big.Contact..Interest.Finder...Hobbies <- NULL
df$Big.Contact..Created.Date <- NULL
df$Big.Enrollment..Created.Date <- NULL
df$Little.Contact..Interest.Finder...Sports <- NULL
df$Little.Contact..Interest.Finder...Outdoors <- NULL
df$Little.Contact..Interest.Finder...Arts <- NULL
df$Little.Contact..Interest.Finder...Places.To.Go <- NULL
df$Little.Contact..Interest.Finder...Hobbies <- NULL
df$Little.Contact..Interest.Finder...Entertainment <- NULL
df$Little.Contact..Interest.Finder...Other.Interests <- NULL
df$Little.Other.Interests <- NULL
df$Little.Contact..Interest.Finder...Career <- NULL
df$Little.Contact..Interest.Finder...Personality <- NULL
df$Little.Contact..Interest.Finder...Three.Wishes <- NULL
df$Little.Other.Interests <- NULL

```


removing high missingness data
```{r}

# Calculate the number of missing values for each column
na_counts <- sapply(df, function(x) sum(is.na(x)))

# Print columns sorted by number of missing values (optional)
na_counts_sorted <- sort(na_counts, decreasing = TRUE)
print(na_counts_sorted)

# Identify columns with more than 3000 missing values
high_missing_cols <- names(na_counts[na_counts > 3000])
print(paste("Columns with >3000 missing values to remove:", length(high_missing_cols)))
print(high_missing_cols)

# Check if we'd be removing all columns
if (length(high_missing_cols) == ncol(df)) {
  print("WARNING: All columns have >3000 missing values. No columns will be removed.")
} else if (length(high_missing_cols) > 0) {
  # Create new dataframe without high-missingness columns
  df_reduced <- df[, !names(df) %in% high_missing_cols]
  print(paste("Original dimensions:", dim(df)[1], "rows,", dim(df)[2], "columns"))
  print(paste("New dimensions:", dim(df_reduced)[1], "rows,", dim(df_reduced)[2], "columns"))
  
  # Assign to df only if the result is not empty
  if (ncol(df_reduced) > 0) {
    df <- df_reduced
    print("Successfully removed high-missingness columns.")
  } else {
    print("ERROR: Removing these columns would result in an empty dataframe. No changes made.")
  }
} else {
  print("No columns with >3000 missing values found.")
}

```


Changing Big.County:
```{r}
consolidate_counties <- function(county_data, min_frequency = 10) {
  consolidated <- county_data
  county_counts <- table(county_data[county_data != ""])
  rare_counties <- names(county_counts[county_counts < min_frequency])
  consolidated[consolidated %in% rare_counties] <- "Other"
  # Convert to factor with meaningful levels
  consolidated <- factor(consolidated)
  
  return(consolidated)
}

df$County_Factor <- consolidate_counties(df$Big.County)
summary(df$County_Factor)
```

Changing Big Occupation, Closure Reason:
```{r}
# Function to categorize text fields based on keywords
categorize_text <- function(text_vector, category_rules, default_category = "Other") {
  result <- rep(default_category, length(text_vector))
  
  if(any(is.na(text_vector))) {
    result[is.na(text_vector)] <- NA
  }
  
  text_vector <- tolower(trimws(text_vector))
  
  for(i in 1:length(category_rules)) {
    category_name <- names(category_rules)[i]
    keywords <- category_rules[[i]]
    
    for(j in which(!is.na(text_vector))) {
      if(any(sapply(tolower(keywords), function(kw) grepl(kw, text_vector[j], ignore.case = TRUE)))) {
        result[j] <- category_name
      }
    }
  }
  
  result <- factor(result)
  return(result)
}

# Define category rules for each text field
closure_reason_rules <- list(
  "Scheduling_Issues" = c("schedule", "time", "availability", "busy", "time constraint"),
  "Relationship_Problems" = c("relationship", "conflict", "disagree", "personal", "not compatible", "incompatible", "lost contact", "lost interest"),
  "Relocation" = c("move", "moved", "relocation", "relocate", "different city", "different state"),
  "Family_Issues" = c("family", "parent", "guardian", "parental"),
  "School_Issues" = c("school", "academic", "education", "grade", "graduated", "graduate"),
  "Health_Issues" = c("health", "illness", "medical", "sick", "disease", "covid", "deceased"),
  "Behavior_Issues" = c("behavior", "conduct", "attitude", "disciplin"),
  "Program_Requirements" = c("requirement", "qualify", "eligibility", "criteria", "guideline", "infraction", "expectations", "challenges"),
  "Success" = c("success", "successful")
)

occupation_rules <- list(
  "Business_Finance" = c("account", "financ", "budget", "analyst", "bank", "economic", "market", "business", "consultant", "insurance", "entrepreneur"),
  "Education" = c("teach", "professor", "instructor", "education", "academic", "school", "college", "university"),
  "Healthcare" = c("doctor", "nurse", "medical", "health", "dental", "therapist", "clinic", "hospital", "coach"),
  "Technology" = c("software", "developer", "engineer", "IT", "computer", "tech", "program", "web", "data"),
  "Legal" = c("lawyer", "attorney", "legal", "law", "judge", "paralegal"),
  "Arts_Media" = c("artist", "design", "writer", "media", "journalist", "creative", "music", "film", "arts"),
  "Service_Industry" = c("retail", "sales", "service", "hospitality", "restaurant", "customer", "child"),
  "Trades_Labor" = c("construct", "mechanic", "carpenter", "electric", "plumb", "repair", "builder", "labor"),
  "Student" = c("student", "graduate", "undergrad"),
  "Unknown" = c("unknown"),
  "Retired" = c("retire")
)


# Example usage:
# Assuming your data is in a dataframe called 'data'
df$Closure_Reason_Category <- categorize_text(df$Closure.Reason, closure_reason_rules)
df$Occupation_Category <- categorize_text(df$Big.Occupation, occupation_rules)
summary(df$Closure_Reason_Category)
summary(df$Occupation_Category)
```
```{r}
# Find indices where Closure_Reason_Category is "Other"
indices <- which(df$Occupation_Category[1:200] == "Other")
matched_reasons <- df$Big.Occupation[indices]
print(matched_reasons)
```

Looking at Closure_Reason:
```{r}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(tidyr)
library(forcats)

# Assuming 'df' is your dataframe with the data
# Let's first look at summary statistics for Match.Length by Closure.Reason
match_summary <- df %>%
  group_by(Closure_Reason_Category) %>%
  summarise(
    count = n(),
    mean_length = mean(Match.Length, na.rm = TRUE),
    median_length = median(Match.Length, na.rm = TRUE),
    sd_length = sd(Match.Length, na.rm = TRUE),
    min_length = min(Match.Length, na.rm = TRUE),
    max_length = max(Match.Length, na.rm = TRUE)
  ) %>%
  arrange(desc(count))

# Print summary
print(match_summary)

# 1. Boxplot of Match.Length by Closure_Reason_Category
closure_boxplot <- ggplot(df, aes(x = reorder(Closure_Reason_Category, Match.Length, FUN = median), 
                                  y = Match.Length, 
                                  fill = Closure_Reason_Category)) +
  geom_boxplot() +
  coord_flip() +
  labs(title = "Distribution of Match Length by Closure Reason",
       x = "Closure Reason",
       y = "Match Length") +
  theme_minimal() +
  theme(legend.position = "none")

print(closure_boxplot)

# 2. Barplot for average Match.Length by Closure_Reason_Category
avg_match_length <- df %>%
  group_by(Closure_Reason_Category) %>%
  summarise(avg_length = mean(Match.Length, na.rm = TRUE),
            count = n()) %>%
  arrange(desc(avg_length))

avg_length_plot <- ggplot(avg_match_length, aes(x = reorder(Closure_Reason_Category, avg_length), 
                                               y = avg_length, 
                                               fill = count)) +
  geom_col() +
  coord_flip() +
  scale_fill_viridis_c(name = "Count") +
  labs(title = "Average Match Length by Closure Reason",
       x = "Closure Reason",
       y = "Average Match Length") +
  theme_minimal()

print(avg_length_plot)

# 3. Density plot for Match.Length by top closure reasons
# Select top 5 most common closure reasons for clarity
top_reasons <- match_summary %>%
  top_n(5, count) %>%
  pull(Closure_Reason_Category)

density_plot <- df %>%
  filter(Closure_Reason_Category %in% top_reasons) %>%
  ggplot(aes(x = Match.Length, fill = Closure_Reason_Category)) +
  geom_density(alpha = 0.7) +
  labs(title = "Density Distribution of Match Length by Top 5 Closure Reasons",
       x = "Match Length",
       y = "Density") +
  theme_minimal()

print(density_plot)

# 4. Histogram of Match.Length faceted by Closure_Reason_Category
histogram_plot <- df %>%
  filter(Closure_Reason_Category %in% top_reasons) %>%
  ggplot(aes(x = Match.Length, fill = Closure_Reason_Category)) +
  geom_histogram(binwidth = 30, alpha = 0.8) +
  facet_wrap(~Closure_Reason_Category, scales = "free_y") +
  labs(title = "Distribution of Match Length by Top Closure Reasons",
       x = "Match Length (days)",
       y = "Count") +
  theme_minimal() +
  theme(legend.position = "none")

print(histogram_plot)

# 5. Create a violin plot to show distribution shapes
violin_plot <- df %>%
  filter(Closure_Reason_Category %in% top_reasons) %>%
  ggplot(aes(x = Closure_Reason_Category, y = Match.Length, fill = Closure_Reason_Category)) +
  geom_violin(trim = FALSE) +
  geom_boxplot(width = 0.1, fill = "white", alpha = 0.5) +
  coord_flip() +
  labs(title = "Violin Plot of Match Length by Top Closure Reasons",
       x = "Closure Reason",
       y = "Match Length") +
  theme_minimal() +
  theme(legend.position = "none")

print(violin_plot)

# 6. Scatter plot with jittering to show individual data points
jitter_plot <- df %>%
  filter(Closure_Reason_Category %in% top_reasons) %>%
  ggplot(aes(x = Closure_Reason_Category, y = Match.Length, color = Closure_Reason_Category)) +
  geom_jitter(alpha = 0.5, width = 0.3) +
  stat_summary(fun = mean, geom = "point", shape = 18, size = 4, color = "black") +
  coord_flip() +
  labs(title = "Individual Match Lengths by Closure Reason (with means)",
       x = "Closure Reason",
       y = "Match Length") +
  theme_minimal()

print(jitter_plot)

# 7. Cumulative distribution function plot
cdf_plot <- df %>%
  filter(Closure_Reason_Category %in% top_reasons) %>%
  ggplot(aes(x = Match.Length, color = Closure_Reason_Category)) +
  stat_ecdf() +
  labs(title = "Cumulative Distribution of Match Length by Closure Reason",
       x = "Match Length",
       y = "Cumulative Proportion") +
  theme_minimal()

print(cdf_plot)

# 8. Proportion of closure reasons
prop_plot <- df %>%
  count(Closure_Reason_Category) %>%
  mutate(prop = n / sum(n)) %>%
  ggplot(aes(x = "", y = prop, fill = Closure_Reason_Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  labs(title = "Proportion of Closure Reasons") +
  theme_void()

print(prop_plot)
```
Other is more because it includes blank values which are matches that are ongoing.



